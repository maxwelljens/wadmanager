#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

use Modern::Perl '2023';
use autodie qw(:all);
no warnings 'once';
use Data::Dumper;
use File::Find;
use File::Path qw(make_path);
use File::Slurper 'read_text';
use File::XDG;
use Getopt::Long qw(:config gnu_getopt auto_help auto_version);
use Term::ANSIColor;
use TOML::Tiny qw(from_toml);

$main::VERSION = '1.0.0';

### Main variables
my $xdg = File::XDG->new( name => 'gibman', api => 1 );
my $config_dir = $xdg->config_home;
my $user_config = $config_dir . '/config.toml';

### Variables for options
my $preset = ''; # Preset to use, as defined in user's config file
my $args = ''; # Arguments to pass to the DOOM engine
my $test = 0;
my $verbose = 0; # Verbose output if true

GetOptions(
  'p|preset=s' => \$preset,
  'a|args=s' => \$args,
  't|test' => \$test,
  'v|verbose' => \$verbose,
)
or exit(1);

if ($test) {
  init_config();
  read_config();
}

sub error_print($error) {
  print colored(['bold red'], 'Error: ');
  say $error;
  exit(1);
}

sub warning_print($warning) {
  if ($verbose) {
    print colored(['bold yellow'], 'Warning: ');
    say $warning;
  }
}

sub verbose_print($message, $type = '') {

  sub print_prefix($prefix) {
    print colored(['bold'], "$prefix: ");
  }

  # Add a prefix to message according to type
  if ($verbose) {
    if ($type eq 'config') { print_prefix("Configuration") }
  }

  # Then the message
  say $message;
}

sub init_config() {
  if (-e $user_config) {
    verbose_print("Found configuration file at $user_config.", 'config');
  } else {
    warning_print("Config file at path $user_config doesn't exist. Creating one from defaults.");

    # Create directory
    unless (-e $config_dir) {
      make_path($config_dir)
      and verbose_print("Successfully created $config_dir", 'config')
      or error_print('Failed to create path at ' . $config_dir . ". $!.");
    }

    # Create file
    open(FH, '>', $user_config) or error_print($!);
    print FH DEFAULT_CONFIG();
    close(FH);
  }
}

sub read_config() {
  my ($parsed_config, $error) = from_toml read_text($user_config);
  if ($error) {
    error_print("Problem parsing configuration file. $error");
  }
  system("$parsed_config->{'default_engine'} -iwad $parsed_config->{'default_iwad'}");
}

use constant DEFAULT_CONFIG => q{# This is the default config file for gibman. Refer to README.md or man page
# for further information on how to configure your instance of gibman.

# You can specify path(s) for all IWADs, which will allow you to use
# relative paths for IWAD entries, instead of absolute paths.
iwad_paths = [
  "/path/to/iwads",
]

# You can specify path(s) for all WADs, which will allow you to use
# relative paths for WAD entries, instead of absolute paths, just like with
# IWADs as above
wad_paths = [
  "/path/to/wads",
]

# Whether search for contents in path(s) specified should be recursive. Can
# make gibman very slow to launch if specified path(s) contains many files
# and directories.
recursive_search = false

# Default IWAD to use when running gibman with no arguments or a preset that
# does not specify an IWAD to use. The entry can be a name from the [iwad]
# table or absolute path to an IWAD.
default_iwad = "doom"

# Default engine to use when running gibman with no arguments or a preset that
# does not specify an engine to use. The engine can be the name as in your
# system $PATH or absolute path name to the engine executable.
default_engine = "gzdoom"

[iwad]
# Relative paths do not need to be exact and are case insensitive, so "doom2"
# should work just as fine as "DOOM2.WAD". Absolute paths, on the other hand,
# must be exact.
doom = "doom"
doom2 = "/path/to/DOOM2.WAD"
tnt = ""
plutonia = ""
heretic = ""
hexen = ""
strife = ""

[wad]
# Specify WAD names and where they reside. Names can be used in preset
# configuration. The path can be absolute, like so (as always, must be exact):
wad1 = "/path/to/foobar.wad"

# Or relative, if you have specified a WAD directory (wad_paths, see above):
wad2 = "wad2"

[engine]
# You do not need to change anything here if your engine is already in PATH on
# your system. If not, write down the exact path to it.
gzdoom = ""
zdoom = ""
boom = "/path/to/boom"

# Non-functional example preset outlined below, which you can invoke by
# running 'gibman -p example'
# You can omit iwad and engine values if you specified default_iwad and
# default_engine in the preset
# Preset names can be anything as long as they are only alphanumeric
# characters, underscores, and hyphens

[preset.example]
iwad = "doom2"
engine = "gzdoom"
note = "If you got a lot of presets, you can write notes to help yourself"
wads = [
  # You can use paths for anonymous WADs, or names in [wad.list].
  # Load order is top to bottom.
  "wad1",
  "wad2",
  "/path/to/example.wad"
]};

